01. 逻辑与(&) 逻辑与(&&) 按位与(&)

02. 方法的重载(方法名相同, 参数列表不同(个数, 类型, 顺序(类型顺序)), 与返回值类型无关), 方法的重写(子类重写父类的方法)
    方法签名通过方法名, 参数个数, 参数类型, 参数类型顺序确定, 与返回值类型无关.
	两个方法仅仅返回值类型不同, 编译器认为它们具有相同的签名

03. 数组的声明:
    数据类型[] 数组名 = new 数据类型[m](推荐)
	数据类型 数组名[] = new 数据类型[m]

04. 数组打印结果: [I@15db9742
	[: 一维数组
	I: int
	@: 固定分隔符
	15db9742: 16进制值, 内存地址

05. 基本数据类型的数组定义后有默认初始值(0, 0.0, false)
	基本数据类型的变量必须初始化后才能使用!

06. 数组静态初始化
    1. int[] arr = new int[]{12, 11, 10}
	2. int[] arr = {12, 11, 10}

07. 空指针错误
    int[] arr = {12, 11, 10};
	arr = null;
	System.out.println(arr[0]); // 抛出空指针异常

08. 二维数组声明:
    数据类型[][] 数组名 = new 数据类型[m][n](推荐)
	数据类型 数组名[][] = new 数据类型[m][n]
	数据类型[] 数组名[] = new 数据类型[m][n]

09. 二维数组说明:
    数组的元素也是一个数组.
	数据类型[m][n]: 一个存放一维数组的数组, 二维数组是长度为m的数组, 一维数组是长度为n的数组.
	m行, n列. 行指针, 列指针. 行指针指向一维数组, 列指针指向最终元素

10. 二维数组声明细节:
    int[][] arr = new int[3][2]
	int[][] arr = new int[3][] (一维数组的长度不确定)
	int[][] arr = {{1, 2}, {3, 4}, {5, 6, 7}}

11. 数据类型:
    1. 基本数据类型: byte, short, int, long, char, double, float, boolean. 变量存的是值.
	2. 引用数据类型: 数组, 类, 接口, 枚举. 变量存的是地址.

12. Java的传值与传地址
    1. 基本数据类型传值, 引用数据类型传地址
	2. Java中只有传值, 地址也是值!!!

13. 创建对象
    类名 变量名 = new 类名()
	
14. 垃圾回收机制
    Java会自动回收无用(没有被引用)对象占用的内存空间
	
15. main 方法是整个程序的入口

16. 在同一个 .java 文件中, 不能有 2 个 public 的 class

17. 在同一个包内不能有相同的类

18. 成员变量与局部变量
    成员变量(属性): 在堆内存(对象进堆), 有默认初始值(0, 0.0, false, null)
	局部变量: 在栈内存(方法进栈), 没有默认初始值(赋值后才能使用)
	
19. 匿名对象
    没有用一个变量引用新创建的对象
	
20. 打印对象
    包名.类名@地址
	
21. 权限关键字
    1. private: 只能本类中访问
	
22. 属性声明规范
    1. 使用private关键字
	2. 提供set/get方法
	3. set/get方法名中属性首字母大写
	
23. this关键字
    1. 与Swift中的self关键字同义
    2. 可以调用本类的构造方法 this(...)

	
24. 构造方法
    1. 作用: 给对象的数据(属性)进行初始化赋值
	2. 格式: 方法名与类名相同; 没有返回值类型; 没有return语句; 有权限关键字.
	3. 有参构造方法, 无参构造方法
	4. 构造方法的重载(与普通方法一样, 只是针对构造方法的重载)
	5. 没有给出构造方法, 系统提供默认的无参构造方法(建议永远自己给出无参构造方法)
	6. 给出了构造方法, 系统不再任何提供构造方法
	7. 正确格式 public 类名(...) { ... }

25. static 关键字
    1. 类加载的时候被加载
    2. 优先于对象存在
    3. 被类的所有对象共享
    4. 共性用静态, 特性用非静态
    5. 类名.属性

26. static 注意
    1. 即可修饰属性, 也可修饰方法
    2. 静态方法中没有 this 关键字(this 是指的当前对象, 静态方法随类存在而存在)
    3. 静态方法只能访问静态成员变量和静态的成员方法
    4. 非静态方法可以访问静态成员变量和静态成员方法

27. 静态变量与成员变量
    1. 静态变量: 类变量; 成员变量: 对象变量
    2. 静态变量属于类, 成员变量属于对象
    3. 静态变量: 方法区的静态区; 成员变量: 堆内存
    4. 静态变量: 随着类的加载而加载, 随着类的消失而消失
       成员变量: 随着对象的创建而创建, 随着对象的消失而消失
    5. 静态变量: 可以通过类名调用, 也可以通过对象调用(不推荐)
       成员变量: 只能通过对象调用

28. 如果一个类中所有的方法都是静态方法. 就不需要构造方法了.
    这时需要私有构造方法, 目的是不让其他类创建本类对象

29. 文档注释 /** */. 用于方法和类上

30. 代码块
    1. {} 括起来的代码称为代码块
    2. 分类:
       a. 局部代码块: 方法中使用, 限定变量生命周期, 及早释放内存, 提高内存利用率
       b. 构造代码块: 类中方法外使用, 多个构造方法中相同的代码存放在一起, 
                      每次调用构造方法都执行, 并且在构造方法前执行
       c. 静态代码块: 类中方法外使用, 使用 static 修饰. 用于给类初始化.
                      类加载的时候执行, 并且只执行一次. 从始至终只运行一次.
                      一般用于加载驱动(例如mysql)
       d. 同步代码块

31. 继承: extends
    1. 子类只能继承父类所有非私有的成员(成员方法和成员变量)
    2. 子类可以通过 super 关键字访问父类的构造方法

32. super: 当前类的对象的父类引用
    调用父类的构造方法, super(...)

33. 子类, 父类属性和方法的访问
    1. 如果子类有这个属性和方法, 就访问自己的
    2. 如果子类没有, 就访问父类, 一级级访问, 直到访问到为止
    3. 如果需要调用父类的属性和方法, 请使用 super 关键字

34. 声明一个类时, 如果实现了自己的构造方法, 
    就需要手动实现一个无参的构造方法, 
    因为子类的构造方法如果不显式调用父类构造方法, 
    就会自动调用这个无参构造方法
