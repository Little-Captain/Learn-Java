001. 逻辑与(&) 逻辑与(&&) 按位与(&)

002. 方法的重载(方法名相同, 参数列表不同(个数, 类型, 顺序(类型顺序)), 与返回值类型无关), 方法的重写(子类重写父类的方法)
     方法签名通过方法名, 参数个数, 参数类型, 参数类型顺序确定, 与返回值类型无关.
	 两个方法仅仅返回值类型不同, 编译器认为它们具有相同的签名

003. 数组的声明:
     数据类型[] 数组名 = new 数据类型[m](推荐)
	 数据类型 数组名[] = new 数据类型[m]

004. 数组打印结果: [I@15db9742
	 [: 一维数组
	 I: int
	 @: 固定分隔符
	 15db9742: 16进制值, 内存地址

005. 基本数据类型的数组定义后有默认初始值(0, 0.0, false)
	 基本数据类型的变量必须初始化后才能使用!

006. 数组静态初始化
     1. int[] arr = new int[]{12, 11, 10}
	 2. int[] arr = {12, 11, 10}

007. 空指针错误
     int[] arr = {12, 11, 10};
	 arr = null;
	 System.out.println(arr[0]); // 抛出空指针异常

008. 二维数组声明:
     数据类型[][] 数组名 = new 数据类型[m][n](推荐)
	 数据类型 数组名[][] = new 数据类型[m][n]
	 数据类型[] 数组名[] = new 数据类型[m][n]

009. 二维数组说明:
     数组的元素也是一个数组.
	 数据类型[m][n]: 一个存放一维数组的数组, 二维数组是长度为m的数组, 一维数组是长度为n的数组.
	 m行, n列. 行指针, 列指针. 行指针指向一维数组, 列指针指向最终元素

010. 二维数组声明细节:
     int[][] arr = new int[3][2]
	 int[][] arr = new int[3][] (一维数组的长度不确定)
	 int[][] arr = {{1, 2}, {3, 4}, {5, 6, 7}}

011. 数据类型:
     1. 基本数据类型: byte, short, int, long, char, double, float, boolean. 变量存的是值.
	 2. 引用数据类型: 数组, 类, 接口, 枚举. 变量存的是地址.

012. Java的传值与传地址
     1. 基本数据类型传值, 引用数据类型传地址
  	 2. Java中只有传值, 地址也是值!!!

013. 创建对象
     类名 变量名 = new 类名()
	
014. 垃圾回收机制
     Java会自动回收无用(没有被引用)对象占用的内存空间
	
015. main 方法是整个程序的入口

016. 在同一个 .java 文件中, 不能有 2 个 public 的 class

017. 在同一个包内不能有相同的类

018. 成员变量与局部变量
     成员变量(属性): 在堆内存(对象进堆), 有默认初始值(0, 0.0, false, null)
	 局部变量: 在栈内存(方法进栈), 没有默认初始值(赋值后才能使用)
	
019. 匿名对象
     没有用一个变量引用新创建的对象
	
020. 打印对象
     包名.类名@地址
	
021. 权限关键字
     1. private: 只能本类中访问
	
022. 属性声明规范
     1. 使用private关键字
	 2. 提供set/get方法
	 3. set/get方法名中属性首字母大写
	
023. this关键字
     1. 与Swift中的self关键字同义
     2. 可以调用本类的构造方法 this(...)

	
024. 构造方法
     1. 作用: 给对象的数据(属性)进行初始化赋值
	 2. 格式: 方法名与类名相同; 没有返回值类型; 没有return语句; 有权限关键字.
	 3. 有参构造方法, 无参构造方法
	 4. 构造方法的重载(与普通方法一样, 只是针对构造方法的重载)
	 5. 没有给出构造方法, 系统提供默认的无参构造方法(建议永远自己给出无参构造方法)
	 6. 给出了构造方法, 系统不再任何提供构造方法
	 7. 正确格式 public 类名(...) { ... }

025. static 关键字
     1. 类加载的时候被加载
     2. 优先于对象存在
     3. 被类的所有对象共享
     4. 共性用静态, 特性用非静态
     5. 类名.属性

026. static 注意
     1. 即可修饰属性, 也可修饰方法
     2. 静态方法中没有 this 关键字(this 是指的当前对象, 静态方法随类存在而存在)
     3. 静态方法只能访问静态成员变量和静态的成员方法
     4. 非静态方法可以访问静态成员变量和静态成员方法

027. 静态变量与成员变量
     1. 静态变量: 类变量; 成员变量: 对象变量
     2. 静态变量属于类, 成员变量属于对象
     3. 静态变量: 方法区的静态区; 成员变量: 堆内存
     4. 静态变量: 随着类的加载而加载, 随着类的消失而消失
        成员变量: 随着对象的创建而创建, 随着对象的消失而消失
     5. 静态变量: 可以通过类名调用, 也可以通过对象调用(不推荐)
        成员变量: 只能通过对象调用

028. 如果一个类中所有的方法都是静态方法. 就不需要构造方法了.
     这时需要私有构造方法, 目的是不让其他类创建本类对象

029. 文档注释 /** */. 用于方法和类上

030. 代码块
     1. {} 括起来的代码称为代码块
     2. 分类:
        a. 局部代码块: 方法中使用, 限定变量生命周期, 及早释放内存, 提高内存利用率
        b. 构造代码块: 类中方法外使用, 多个构造方法中相同的代码存放在一起, 
                       每次调用构造方法都执行, 并且在构造方法前执行
        c. 静态代码块: 类中方法外使用, 使用 static 修饰. 用于给类初始化.
                       类加载的时候执行, 并且只执行一次. 从始至终只运行一次.
                       一般用于加载驱动(例如mysql)
        d. 同步代码块

031. 继承: extends
     1. 子类只能继承父类所有非私有的成员(成员方法和成员变量)
     2. 子类可以通过 super 关键字访问父类的构造方法

032. super: 当前类的对象的父类引用
     调用父类的构造方法, super(...)

033. 子类, 父类属性和方法的访问
     1. 如果子类有这个属性和方法, 就访问自己的
     2. 如果子类没有, 就访问父类, 一级级访问, 直到访问到为止
     3. 如果需要调用父类的属性和方法, 请使用 super 关键字

034. 声明一个类时, 如果实现了自己的构造方法, 
     就需要手动实现一个无参的构造方法, 
     因为子类的构造方法如果不显式调用父类构造方法, 
     就会自动调用这个无参构造方法
	
035. this
     调用本类的构造方法, this(...)
	
036. 继承中构造方法的关系
     1. 子类中所有的构造方法默认都会首先访问父类中空参的构造方法. 默认有super()这行代码, 写不写是一样的!
	 2. 子类初始化前, 一定要先完成父类数据的初始化
	 3. 每个构造方法的第一条语句都必须是super(...).
	 4. this(...)构造也必须是第一条语句. 也就是先完成构造, 再使用.
	 5. Object 是最顶层的父类 (class P extends Object {} <=> class P {})
	
037. 继承中构造方法的注意事项
     1. 父类没有无参构造方法的处理
	    a. 子类创建无参构造方法, 然后显示调用父类的有参构造方法
	    b. 子类实现有参构造方法, 然后显示调用父类的有参构造方法
	    c. 父类实现无参构造方法
       
038. 方法重写
     1. 父类中私有方法不能被重写, 因为父类私有方法子类根本无法继承
     2. 子类重写父类方法时, 访问权限最好一致
    
039. final 关键字
     1. 修饰类, 类不能被继承
     2. 修饰变量, 变量就变成了常量, 只能被赋值一次. 一般和 public static 共用
        常量命名规范, 单词大写, 单词间使用下划线连接
     3. 修饰方法, 方法不能被重写
     4. final 使用前, 必须初始化.
        a. 类中: 静态, 必须马上初始化; 非静态, 马上或构造方法中
        b. 局部: 一旦赋值, 不能再改变, 但必须在使用前赋值
       
040. 多态: 事物存在的多种形态
     Java 中多态存在的前提条件, 三者缺一不可!!!
     1. 继承关系
     2. 方法重写
     3. 父类引用指向子类对象
     
041. 多态中成员访问特点
     1. 成员变量: 编译看左边(父类), 运行看左边(父类)
     2. 成员方法: 编译看左边(父类), 运行看右边(子类)
     3. 静态方法: 编译看左边(父类), 运行看左边(父类). 静态方法不会通过对象去调用.
     4. 静态变量: 编译看左边(父类), 运行看左边(父类). 静态变量不会通过对象去调用.
     5. 总结: Java 中只有运行时成员方法(对象方法), 即多态形成!!! 多态调用对象方法, 执行时看子类的方法.
     
042. 子父类间的类型转换
     1. 向上转型: 子类 -> 父类
     2. 向下转型: 父类 -> 子类 (需要强制类型转换, 如果真实类型不匹配会抛出类型转换异常ClassCastException)
     
043. 多态的好处
     1. 提高代码的维护性(继承保证)
        如: 在父类改一个属性不用每个子类都改属性
     2. 提高代码的扩展性(多态保证)
        如: 方法中使用父类为参数, 来实现方法或属性的调用

044. 多态的弊端
     1. 不能使用子类特有的属性和方法
     
045. 抽象类
     1. 抽象类和抽象方法必须用 abstract 关键字修饰
        abstract class 类名 {}
        public abstract void eat() {}
        abstract 不能修饰类方法: abstract static 冲突
        abstract 不能修饰不能被重写的方法: abstract final 冲突
        abstract 不能修饰本类私有的方法: abstract private 冲突
     2. 抽象类不一定有抽象方法, 有抽象方法的类一定是个抽象类或接口
     3. 抽象类不能实例化. 必须由具体的子类实例化(多态: 抽象类多态)
     4. 抽象类的子类
        要么是抽象类
        要么重写抽象类中的所有抽象方法
        
046. 抽象类的成员特点
     1. 成员变量: 可以是变量也可以是常量
     2. abstract 不能修饰成员变量, 只能修饰类和方法
     3. 构造方法: 抽象类也有构造方法, 用于子类访问父类数据的初始化
     4. 成员方法: 抽象类的方法可以是抽象的, 也可以是非抽象的
        抽象方法: 强制要求子类实现
        非抽象方法: 子类一般会继承实现自己的业务, 提高代码的复用性
        
047. 接口
     1. Java 中的 interface
     2. 对外提供的规则
     3. interface 接口名 {}
     4. 类实现接口 class 类名 implements 接口名 {}
        接口的实现类; 接口的子类
     5. 接口不能实例化对象(按照多态的方式类实例化)
     6. 接口的子类
        a. 可以是抽象类, 但意义不大
        b. 可以是具体类, 要重写接口中的所有方法
     7. 接口中声明的方法都是抽象方法
     
048. 类与类, 类与接口, 接口与接口之间的关系
     1. 类与类: 继承关系. 只能单继承
     2. 类与接口: 实现关系. 可以单实现, 也可以多实现
                 还可以在继承一个类的同时实现多个接口 class A extends B implements C, D {}
     3. 接口与接口: 继承关系. 可以单继承, 也可以多继承 interface A extends B, C {}