001. 逻辑与(&) 逻辑与(&&) 按位与(&)

002. 方法的重载(方法名相同, 参数列表不同(个数, 类型, 顺序(类型顺序)), 与返回值类型无关), 方法的重写(子类重写父类的方法)
     方法签名通过方法名, 参数个数, 参数类型, 参数类型顺序确定, 与返回值类型无关.
	 两个方法仅仅返回值类型不同, 编译器认为它们具有相同的签名

003. 数组的声明:
     数据类型[] 数组名 = new 数据类型[m](推荐)
	 数据类型 数组名[] = new 数据类型[m]

004. 数组打印结果: [I@15db9742
	 [: 一维数组
	 I: int
	 @: 固定分隔符
	 15db9742: 16进制值, 内存地址

005. 基本数据类型的数组定义后有默认初始值(0, 0.0, false)
	 基本数据类型的变量必须初始化后才能使用!

006. 数组静态初始化
     1. int[] arr = new int[]{12, 11, 10}
	 2. int[] arr = {12, 11, 10}

007. 空指针错误
     int[] arr = {12, 11, 10};
	 arr = null;
	 System.out.println(arr[0]); // 抛出空指针异常

008. 二维数组声明:
     数据类型[][] 数组名 = new 数据类型[m][n](推荐)
	 数据类型 数组名[][] = new 数据类型[m][n]
	 数据类型[] 数组名[] = new 数据类型[m][n]

009. 二维数组说明:
     数组的元素也是一个数组.
	 数据类型[m][n]: 一个存放一维数组的数组, 二维数组是长度为m的数组, 一维数组是长度为n的数组.
	 m行, n列. 行指针, 列指针. 行指针指向一维数组, 列指针指向最终元素

010. 二维数组声明细节:
     int[][] arr = new int[3][2]
	 int[][] arr = new int[3][] (一维数组的长度不确定)
	 int[][] arr = {{1, 2}, {3, 4}, {5, 6, 7}}

011. 数据类型:
     1. 基本数据类型: byte, short, int, long, char, double, float, boolean. 变量存的是值.
	 2. 引用数据类型: 数组, 类, 接口, 枚举. 变量存的是地址.

012. Java的传值与传地址
     1. 基本数据类型传值, 引用数据类型传地址
  	 2. Java中只有传值, 地址也是值!!!

013. 创建对象
     类名 变量名 = new 类名()
	
014. 垃圾回收机制
     Java会自动回收无用(没有被引用)对象占用的内存空间
	
015. main 方法是整个程序的入口

016. 在同一个 .java 文件中, 不能有 2 个 public 的 class

017. 在同一个包内不能有相同的类

018. 成员变量与局部变量
     成员变量(属性): 在堆内存(对象进堆), 有默认初始值(0, 0.0, false, null)
	 局部变量: 在栈内存(方法进栈), 没有默认初始值(赋值后才能使用)
	
019. 匿名对象
     没有用一个变量引用新创建的对象
	
020. 打印对象
     包名.类名@地址
	
021. 权限关键字
     1. private: 只能本类中访问
	
022. 属性声明规范
     1. 使用private关键字
	 2. 提供set/get方法
	 3. set/get方法名中属性首字母大写
	
023. this关键字
     1. 与Swift中的self关键字同义
     2. 可以调用本类的构造方法 this(...)

	
024. 构造方法
     1. 作用: 给对象的数据(属性)进行初始化赋值
	 2. 格式: 方法名与类名相同; 没有返回值类型; 没有return语句; 有权限关键字.
	 3. 有参构造方法, 无参构造方法
	 4. 构造方法的重载(与普通方法一样, 只是针对构造方法的重载)
	 5. 没有给出构造方法, 系统提供默认的无参构造方法(建议永远自己给出无参构造方法)
	 6. 给出了构造方法, 系统不再任何提供构造方法
	 7. 正确格式 public 类名(...) { ... }

025. static 关键字
     1. 类加载的时候被加载
     2. 优先于对象存在
     3. 被类的所有对象共享
     4. 共性用静态, 特性用非静态
     5. 类名.属性

026. static 注意
     1. 即可修饰属性, 也可修饰方法
     2. 静态方法中没有 this 关键字(this 是指的当前对象, 静态方法随类存在而存在)
     3. 静态方法只能访问静态成员变量和静态的成员方法
     4. 非静态方法可以访问静态成员变量和静态成员方法

027. 静态变量与成员变量
     1. 静态变量: 类变量; 成员变量: 对象变量
     2. 静态变量属于类, 成员变量属于对象
     3. 静态变量: 方法区的静态区; 成员变量: 堆内存
     4. 静态变量: 随着类的加载而加载, 随着类的消失而消失
        成员变量: 随着对象的创建而创建, 随着对象的消失而消失
     5. 静态变量: 可以通过类名调用, 也可以通过对象调用(不推荐)
        成员变量: 只能通过对象调用

028. 如果一个类中所有的方法都是静态方法. 就不需要构造方法了.
     这时需要私有构造方法, 目的是不让其他类创建本类对象

029. 文档注释 /** */. 用于方法和类上

030. 代码块
     1. {} 括起来的代码称为代码块
     2. 分类:
        a. 局部代码块: 方法中使用, 限定变量生命周期, 及早释放内存, 提高内存利用率
        b. 构造代码块: 类中方法外使用, 多个构造方法中相同的代码存放在一起, 
                       每次调用构造方法都执行, 并且在构造方法前执行
        c. 静态代码块: 类中方法外使用, 使用 static 修饰. 用于给类初始化.
                       类加载的时候执行, 并且只执行一次. 从始至终只运行一次.
                       一般用于加载驱动(例如mysql)
        d. 同步代码块

031. 继承: extends
     1. 子类只能继承父类所有非私有的成员(成员方法和成员变量)
     2. 子类可以通过 super 关键字访问父类的构造方法

032. super: 当前类的对象的父类引用
     调用父类的构造方法, super(...)

033. 子类, 父类属性和方法的访问
     1. 如果子类有这个属性和方法, 就访问自己的
     2. 如果子类没有, 就访问父类, 一级级访问, 直到访问到为止
     3. 如果需要调用父类的属性和方法, 请使用 super 关键字

034. 声明一个类时, 如果实现了自己的构造方法, 
     就需要手动实现一个无参的构造方法, 
     因为子类的构造方法如果不显式调用父类构造方法, 
     就会自动调用这个无参构造方法
	
035. this
     调用本类的构造方法, this(...)
	
036. 继承中构造方法的关系
     1. 子类中所有的构造方法默认都会首先访问父类中空参的构造方法. 默认有super()这行代码, 写不写是一样的!
	 2. 子类初始化前, 一定要先完成父类数据的初始化
	 3. 每个构造方法的第一条语句都必须是super(...).
	 4. this(...)构造也必须是第一条语句. 也就是先完成构造, 再使用.
	 5. Object 是最顶层的父类 (class P extends Object {} <=> class P {})
	
037. 继承中构造方法的注意事项
     1. 父类没有无参构造方法的处理
	    a. 子类创建无参构造方法, 然后显示调用父类的有参构造方法
	    b. 子类实现有参构造方法, 然后显示调用父类的有参构造方法
	    c. 父类实现无参构造方法
       
038. 方法重写
     1. 父类中私有方法不能被重写, 因为父类私有方法子类根本无法继承
     2. 子类重写父类方法时, 访问权限最好一致
    
039. final 关键字
     1. 修饰类, 类不能被继承
     2. 修饰变量, 变量就变成了常量, 只能被赋值一次. 一般和 public static 共用
        常量命名规范, 单词大写, 单词间使用下划线连接
     3. 修饰方法, 方法不能被重写
     4. final 使用前, 必须初始化.
        a. 类中: 静态, 必须马上初始化; 非静态, 马上或构造方法中
        b. 局部: 一旦赋值, 不能再改变, 但必须在使用前赋值
       
040. 多态: 事物存在的多种形态
     Java 中多态存在的前提条件, 三者缺一不可!!!
     1. 继承关系
     2. 方法重写
     3. 父类引用指向子类对象
     
041. 多态中成员访问特点
     1. 成员变量: 编译看左边(父类), 运行看左边(父类)
     2. 成员方法: 编译看左边(父类), 运行看右边(子类)
     3. 静态方法: 编译看左边(父类), 运行看左边(父类). 静态方法不会通过对象去调用.
     4. 静态变量: 编译看左边(父类), 运行看左边(父类). 静态变量不会通过对象去调用.
     5. 总结: Java 中只有运行时成员方法(对象方法), 即多态形成!!! 多态调用对象方法, 执行时看子类的方法.
     
042. 子父类间的类型转换
     1. 向上转型: 子类 -> 父类
     2. 向下转型: 父类 -> 子类 (需要强制类型转换, 如果真实类型不匹配会抛出类型转换异常ClassCastException)
     
043. 多态的好处
     1. 提高代码的维护性(继承保证)
        如: 在父类改一个属性不用每个子类都改属性
     2. 提高代码的扩展性(多态保证)
        如: 方法中使用父类为参数, 来实现方法或属性的调用

044. 多态的弊端
     1. 不能使用子类特有的属性和方法
     
045. 抽象类
     1. 抽象类和抽象方法必须用 abstract 关键字修饰
        abstract class 类名 {}
        public abstract void eat() {}
        abstract 不能修饰类方法: abstract static 冲突
        abstract 不能修饰不能被重写的方法: abstract final 冲突
        abstract 不能修饰本类私有的方法: abstract private 冲突
     2. 抽象类不一定有抽象方法, 有抽象方法的类一定是个抽象类或接口
     3. 抽象类不能实例化. 必须由具体的子类实例化(多态: 抽象类多态)
     4. 抽象类的子类
        要么是抽象类
        要么重写抽象类中的所有抽象方法
        
046. 抽象类的成员特点
     1. 成员变量: 可以是变量也可以是常量
     2. abstract 不能修饰成员变量, 只能修饰类和方法
     3. 构造方法: 抽象类也有构造方法, 用于子类访问父类数据的初始化
     4. 成员方法: 抽象类的方法可以是抽象的, 也可以是非抽象的
        抽象方法: 强制要求子类实现
        非抽象方法: 子类一般会继承实现自己的业务, 提高代码的复用性
        
047. 接口
     1. Java 中的 interface
     2. 对外提供的规则
     3. interface 接口名 {}
     4. 类实现接口 class 类名 implements 接口名 {}
        接口的实现类; 接口的子类
     5. 接口不能实例化对象(按照多态的方式类实例化)
     6. 接口的子类
        a. 可以是抽象类, 但意义不大
        b. 可以是具体类, 要重写接口中的所有方法
     7. 接口中声明的方法都是抽象方法
     
048. 类与类, 类与接口, 接口与接口之间的关系
     1. 类与类: 继承关系. 只能单继承
     2. 类与接口: 实现关系. 可以单实现, 也可以多实现
                 还可以在继承一个类的同时实现多个接口 class A extends B implements C, D {}
     3. 接口与接口: 继承关系. 可以单继承, 也可以多继承 interface A extends B, C {}
     
049. 独立的 Java 文件
     一般一个类写在一个独立的 Java 文件中
     
050. package 包的作用
     1. 包其实就是文件夹
     2. 作用1: 将字节码(.class)进行分类存放
     3. 作用2: 可以使在同一个项目中有相同的类
     4. 作用3: 有利于以后功能模块的划分
     
051. 定义包的格式
     1. 包名: 公司域名的倒写
     2. 如: com.baidu.功能模块名. 用(.)分隔, 有几个字符串, 就会创建几个文件夹
     
052. 定义包的注意事项
     1. 在包下面创建 Java 文件, 第一行应加入 package 代码, 表名这个类属于哪个包
     2. 如果一个包中的类使用另一个包中的类, 需要使用 import 导入另一个包的类
     3. package 语句必须放在第一行
     4. 一个 Java 文件中只能有一个 package 语句
     
053. import 关键字
     1. 作用: 导入类. 不导入, 不能跨包直接访问另一个包中的类
     2. 使用方式
        a. import com.baidu.model.Student 只导入一个类
        b. import com.baidu.model.* 导入包中的所有类, 不建议这样用
     3. 不导入. 可以通过类的完整名称使用类
        (一般不这样用, 不过可以解决不同包同类名的使用问题)
        com.baidu.model.Student stu = new com.baidu.model.Student();
     4. 包中的类能被其他包访问, 一定是 public 的类.
        public 修饰的类代表其他包可以访问此类
        如果类不是 public, 代表只能在当前包被访问
        
054. package, import, class 在 Java 文件中的顺序
     1. package 只能有一个, 必须放在 Java 文件的第一行
     2. import 只能放在 package 的下面, 多个 import 应放在一起
     3. class 放在 package 和 import 的下面
     4. package -> import -> class
     
055. 四种权限修饰符
     private < default < protected < public
     同一个类
     x         同一个包中的类
     x         x         不同包中的子类
     x         x         x           不同包中的非子类
     一般使用
     1. 主要使用 private, public
     2. 写方法, 一般加上 private 或者 public
     3. 写类的时候, 在类名前加 public
     
056. 常见的修饰符
     1. 权限修饰符: private, default, protected, public
     2. 状态修饰符: static, final
     3. 抽象修饰符: abstract
     
057. 用在类上的修饰符
     1. 权限修饰符: default, public
     2. 状态修饰符: final
     3. 抽象修饰符: abstract
     说明:
     1. 如果一个类不写任何修饰符(default), 代表只能在当前包访问这个类
     2. 如果一个类声明为 public, 代表任何人都能访问这个类
     3. 如果一个类声明为 final, 代表这个类不能被继承
     4. 如果一个类声明为 abstract, 代表这个类是抽象类, 不能实例化对象
     
058. 用在成员变量上的修饰符
     1. 权限修饰符: private, default, protected, public
     2. 状态修饰符: static, final
     说明:
     1. 如果一个属性声明为 private, 代表这个属性只能在当前类中使用
     2. 如果一个属性什么都不声明(default), 在同一个包中能被访问, 其他包不能
     3. 如果一个属性声明为 public, 代表任何地方都能访问这个属性
     4. 如果一个属性声明为 static, 代表静态属性, 通过类名访问
     5. 属性声明为 final, 代表这是个常量
     6. protected
     
059. 用在构造方法上的修饰符
     1. 权限修饰符: private, default, protected, public
     说明:
     1. 使用 public, 代表外面(能使用类的地方)可以使用这个构造方法
     2. 使用 private, 代表外面不能使用这个构造方法
     3. 使用 protected, 代表???
     4. 使用 default(不写), 代表同一个包中能使用这个构造方法
     
060. 用在成员方法上的修饰符
     1. 权限修饰符: private, default, protected, public
     2. 状态修饰符: static, final
     3. 抽象修饰符: abstract
     说明:
     1. 使用 private, 代表只能在当前类中调用
     2. 使用 default(不写), 代表同一个包中能调用方法
     3. 使用 public, 代表任何地方都能访问这个方法
     4. 使用 protected, 代表
     5. 使用 static, 代表静态方法, 通过类名调用
     6. 使用 final, 代表这个方法不能被重写(override)
     7. 使用 abstract, 代表这个方法需要被子类实现
     
061. 修饰符的联用举例
     成员方法:
     1. public static: 静态, 任何地方都能访问
     2. public abstract: 抽象, 子类实现, 任何地方都能访问
     3. public final: 不能被重写, 任何地方都能访问
     成员变量:
     1. public static final: 静态, 常量, 任何地方都能访问
     
062. protected 修饰符
     1. protected修饰的方法只能在当前包中访问, 或者子类中访问
     2. 不用包, 不能访问类的 protected 的方法
     3. 不用包, 通过在子类中去调用父类的 protected 方法
     
063. 抽象类和接口的区别
     1. 抽象类
        成员变量: 可以常量, 也可以变量
        构造方法: 有
        成员方法: 可以抽象, 也可以非抽象
     2. 接口:
        成员变量: 只可以常量(静态)
        成员方法: 只可以抽象
     3. 关系区别:
        类与类: 继承关系, 单继承
        类与接口: 实现关系, 单实现或多实现
        接口与接口: 继承关系, 单继承或多继承
     4. 设计理念区别:
        抽象类: 定义该继承体系中的共性功能
        接口: 定义该继承体系的扩展功能